pragma solidity 0.5.7;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/utils/Address.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "./TokenRecoverable.sol";
import "./ITokenReceiver.sol";


contract NOIAToken is TokenRecoverable, ERC20 {
    using SafeMath for uint256;
    using Address for address;

    string public constant name = "NOIA Token";
    string public constant symbol = "NOIA";
    uint8 public constant decimals = uint8(18); 
    uint256 public tokensToMint = 1000000000e18; // 1 000 000 000 tokens
    address public burnAddress;
    mapping(address => bool) public notify;
    
    function register() public {
        notify[msg.sender] = true;
    }

    function unregister() public {
        notify[msg.sender] = false;
    }

    /**
     * @dev Transfer token to a specified address
     * @param to The address to transfer to.
     * @param value The amount to be transferred.
     */
    function transfer(address to, uint256 value) public returns (bool) {
        bool success = super.transfer(to, value);
        if (success) {
            _postTransfer(msg.sender, to, value);
        }
        return success;
    }

    /**
     * @dev Transfer tokens from one address to another.
     * Note that while this function emits an Approval event, this is not required as per the specification,
     * and other compliant implementations may not emit the event.
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param value uint256 the amount of tokens to be transferred
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        bool success = super.transferFrom(from, to, value);
        if (success) {
            _postTransfer(from, to, value);
        }
        return success;
    }

    function _postTransfer(address from, address to, uint256 value) internal {
        if (to.isContract()) {
            if (notify[to] == false) return;

            ITokenReceiver(to).tokensReceived(from, to, value);
        } else {
            if (to == burnAddress) {
                _burn(burnAddress, value);
            }
        }
    }

    function _burn(address account, uint256 value) internal {
        require(tokensToMint == 0, "All tokens must be minted before burning");
        super._burn(account, value);
    }

    /**
     * @dev Function to mint tokens
     * @param to The address that will receive the minted tokens.
     * @param value The amount of tokens to mint.
     * @return A boolean that indicates if the operation was successful.
     */
    function mint(address to, uint256 value) public onlyOwner returns (bool) {
        require(tokensToMint.sub(value) >= 0, "Not enough tokens left");
        tokensToMint = tokensToMint.sub(value);
        _mint(to, value);
        _postTransfer(address(0), to, value);
        return true;
    }

    /**
     * @dev Burns a specific amount of tokens.
     * @param value The amount of token to be burned.
     */
    function burn(uint256 value) public {
        require(msg.sender == burnAddress, "Only burnAddress can burn tokens");
        _burn(msg.sender, value);
    }

    function setBurnAddress(address _burnAddress) external onlyOwner {
        require(balanceOf(_burnAddress) == 0, "Burn address must have zero balance!");

        burnAddress = _burnAddress;
    }
}